# ------------ Kruskal's Algorithm  ------------

# Find operation with Path Compression
def find(parent, x):
    # If x is not the root, recursively find the root
    if parent[x] != x:
        parent[x] = find(parent, parent[x])   # Path compression
    return parent[x]

# Union operation with Rank
def union(parent, rank, x, y):
    rootX = find(parent, x)
    rootY = find(parent, y)

    # Attach smaller rank tree under bigger rank tree
    if rank[rootX] < rank[rootY]:
        parent[rootX] = rootY
    elif rank[rootX] > rank[rootY]:
        parent[rootY] = rootX
    else:
        # If ranks are same, make one root and increase its rank
        parent[rootY] = rootX
        rank[rootX] += 1

# Kruskal's Algorithm
def kruskal(edges, V):
    # Step 1: Sort all edges by weight (ascending)
    edges.sort(key=lambda x: x[2])

    # Step 2: Create parent[] and rank[] for Disjoint Set
    parent = [i for i in range(V)]   # Initially each vertex is its own parent
    rank   = [0] * V                 # Rank = 0 for all

    mst = []     # To store edges of the Minimum Spanning Tree
    e = 0        # Count edges added to MST (must reach V-1)

    # Step 3: Pick edges one by one from sorted list
    for u, v, w in edges:
        if e == V - 1:      # Stop when MST has V-1 edges
            break

        rootU = find(parent, u)   # Find set of vertex u
        rootV = find(parent, v)   # Find set of vertex v

        # If roots are different â†’ adding edge won't form cycle
        if rootU != rootV:
            mst.append([u, v, w])     # Add edge to MST
            union(parent, rank, rootU, rootV)   # Merge the sets
            e += 1

    return mst

# ------------------ INPUT ------------------
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))

edges = []   # Each element = [u, v, w]
print("Enter edges as: u v weight (0-based indexing):")

for _ in range(E):
    u, v, w = map(int, input().split())
    edges.append([u, v, w])

# ------------------ RUN ------------------
mst = kruskal(edges, V)

print("\nEdges in Minimum Spanning Tree (MST):")
for u, v, w in mst:
    print(f"{u} - {v} : {w}")

